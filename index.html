<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Taro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Babel Standalone for in-browser JSX/TSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="importmap">
{
  "imports": {
    "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
    "react": "https://esm.sh/react@^18.2.0",
    "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@^2.55.0",
    "react-dom/": "https://esm.sh/react-dom@^19.1.1/",
    "react/": "https://esm.sh/react@^19.1.1/"
  }
}
</script>
<style>
  /* Unified Top-to-Bottom Animations for All Screens */
  @keyframes fly-to-slot-0 { /* To left slot */
      from { transform: translate(0, 0) rotateY(0deg) scale(1); opacity: 1; }
      50% { transform: translate(-40px, 120px) rotateY(90deg) scale(0.9); }
      to { transform: translate(-80px, 240px) rotateY(180deg) scale(0.8); opacity: 0; }
  }
  @keyframes fly-to-slot-1 { /* To middle slot */
      from { transform: translate(0, 0) rotateY(0deg) scale(1); opacity: 1; }
      50% { transform: translate(0, 120px) rotateY(90deg) scale(0.9); }
      to { transform: translate(0, 240px) rotateY(180deg) scale(0.8); opacity: 0; }
  }
  @keyframes fly-to-slot-2 { /* To right slot */
      from { transform: translate(0, 0) rotateY(0deg) scale(1); opacity: 1; }
      50% { transform: translate(40px, 120px) rotateY(90deg) scale(0.9); }
      to { transform: translate(80px, 240px) rotateY(180deg) scale(0.8); opacity: 0; }
  }

  .animate-fly-slot-0 { animation: fly-to-slot-0 1.2s ease-in-out forwards; }
  .animate-fly-slot-1 { animation: fly-to-slot-1 1.2s ease-in-out forwards; }
  .animate-fly-slot-2 { animation: fly-to-slot-2 1.2s ease-in-out forwards; }
</style>
</head>
<body class="bg-gray-900">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { createClient } from '@supabase/supabase-js';

      // --- From types.ts ---
      interface TarotCardData {
        id: number;
        name: string; // Korean name for display
        name_en: string; // English name for image URL
        url: string;
      }

      // --- From constants.ts ---
      const SUPABASE_URL = 'https://xkwzpjsbvcilghdsgsld.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhrd3pwanNidmNpbGdoZHNnc2xkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNDgyNTksImV4cCI6MjA3MDgyNDI1OX0.YCO3I8oy4iAYEiHt7BYMDhJIodgq3T0mqdMcEszGtvU';
      const BUCKET_NAME = 'taro_image';
      const TAROT_CARD_DEFINITIONS = [
        { name_en: "The Fool", name_ko: "바보" }, { name_en: "The Magician", name_ko: "마법사" }, { name_en: "The High Priestess", name_ko: "여사제" }, { name_en: "The Empress", name_ko: "여황제" }, { name_en: "The Emperor", name_ko: "황제" }, { name_en: "The Hierophant", name_ko: "교황" }, { name_en: "The Lovers", name_ko: "연인" }, { name_en: "The Chariot", name_ko: "전차" }, { name_en: "Strength", name_ko: "힘" }, { name_en: "The Hermit", name_ko: "은둔자" }, { name_en: "Wheel of Fortune", name_ko: "운명의 수레바퀴" }, { name_en: "Justice", name_ko: "정의" }, { name_en: "The Hanged Man", name_ko: "매달린 남자" }, { name_en: "Death", name_ko: "죽음" }, { name_en: "Temperance", name_ko: "절제" }, { name_en: "The Devil", name_ko: "악마" }, { name_en: "The Tower", name_ko: "탑" }, { name_en: "The Star", name_ko: "별" }, { name_en: "The Moon", name_ko: "달" }, { name_en: "The Sun", name_ko: "태양" }, { name_en: "Judgement", name_ko: "심판" }, { name_en: "The World", name_ko: "세계" },
        { name_en: "Ace of Wands", name_ko: "완드 에이스" }, { name_en: "Two of Wands", name_ko: "완드 2" }, { name_en: "Three of Wands", name_ko: "완드 3" }, { name_en: "Four of Wands", name_ko: "완드 4" }, { name_en: "Five of Wands", name_ko: "완드 5" }, { name_en: "Six of Wands", name_ko: "완드 6" }, { name_en: "Seven of Wands", name_ko: "완드 7" }, { name_en: "Eight of Wands", name_ko: "완드 8" }, { name_en: "Nine of Wands", name_ko: "완드 9" }, { name_en: "Ten of Wands", name_ko: "완드 10" }, { name_en: "Page of Wands", name_ko: "완드 페이지" }, { name_en: "Knight of Wands", name_ko: "완드 나이트" }, { name_en: "Queen of Wands", name_ko: "완드 퀸" }, { name_en: "King of Wands", name_ko: "완드 킹" },
        { name_en: "Ace of Cups", name_ko: "컵 에이스" }, { name_en: "Two of Cups", name_ko: "컵 2" }, { name_en: "Three of Cups", name_ko: "컵 3" }, { name_en: "Four of Cups", name_ko: "컵 4" }, { name_en: "Five of Cups", name_ko: "컵 5" }, { name_en: "Six of Cups", name_ko: "컵 6" }, { name_en: "Seven of Cups", name_ko: "컵 7" }, { name_en: "Eight of Cups", name_ko: "컵 8" }, { name_en: "Nine of Cups", name_ko: "컵 9" }, { name_en: "Ten of Cups", name_ko: "컵 10" }, { name_en: "Page of Cups", name_ko: "컵 페이지" }, { name_en: "Knight of Cups", name_ko: "컵 나이트" }, { name_en: "Queen of Cups", name_ko: "컵 퀸" }, { name_en: "King of Cups", name_ko: "컵 킹" },
        { name_en: "Ace of Swords", name_ko: "소드 에이스" }, { name_en: "Two of Swords", name_ko: "소드 2" }, { name_en: "Three of Swords", name_ko: "소드 3" }, { name_en: "Four of Swords", name_ko: "소드 4" }, { name_en: "Five of Swords", name_ko: "소드 5" }, { name_en: "Six of Swords", name_ko: "소드 6" }, { name_en: "Seven of Swords", name_ko: "소드 7" }, { name_en: "Eight of Swords", name_ko: "소드 8" }, { name_en: "Nine of Swords", name_ko: "소드 9" }, { name_en: "Ten of Swords", name_ko: "소드 10" }, { name_en: "Page of Swords", name_ko: "소드 페이지" }, { name_en: "Knight of Swords", name_ko: "소드 나이트" }, { name_en: "Queen of Swords", name_ko: "소드 퀸" }, { name_en: "King of Swords", name_ko: "소드 킹" },
        { name_en: "Ace of Pentacles", name_ko: "펜타클 에이스" }, { name_en: "Two of Pentacles", name_ko: "펜타클 2" }, { name_en: "Three of Pentacles", name_ko: "펜타클 3" }, { name_en: "Four of Pentacles", name_ko: "펜타클 4" }, { name_en: "Five of Pentacles", name_ko: "펜타클 5" }, { name_en: "Six of Pentacles", name_ko: "펜타클 6" }, { name_en: "Seven of Pentacles", name_ko: "펜타클 7" }, { name_en: "Eight of Pentacles", name_ko: "펜타클 8" }, { name_en: "Nine of Pentacles", name_ko: "펜타클 9" }, { name_en: "Ten of Pentacles", name_ko: "펜타클 10" }, { name_en: "Page of Pentacles", name_ko: "펜타클 페이지" }, { name_en: "Knight of Pentacles", name_ko: "펜타클 나이트" }, { name_en: "Queen of Pentacles", name_ko: "펜타클 퀸" }, { name_en: "King of Pentacles", name_ko: "펜타클 킹" }
      ];

      // --- From services/supabaseService.ts ---
      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      function getCardImageUrl(cardId, cardName) {
        const fileName = `${cardName.trim().replace(/\s+/g, '_')}.png`;
        const imagePath = `cards/${fileName}`;
        const { data } = supabase.storage.from(BUCKET_NAME).getPublicUrl(imagePath);
        if (!data.publicUrl) {
          console.error(`Could not get public URL for path: ${imagePath}.`);
          return `https://picsum.photos/400/600?random=${cardId}`;
        }
        return data.publicUrl;
      }

      // --- From components/LoadingSpinner.tsx ---
      const LoadingSpinner = ({ size = 'md', className = '' }) => {
        const sizeClasses = { sm: 'w-6 h-6', md: 'w-10 h-10', lg: 'w-16 h-16' };
        return (
          <div className={`flex justify-center items-center ${className}`}>
            <div className={`animate-spin rounded-full ${sizeClasses[size]} border-t-2 border-b-2 border-purple-400`}></div>
          </div>
        );
      };

      // --- From components/TarotCard.tsx ---
      const TarotCard = ({ card, isRevealed, isSelected = false, onClick, size = 'lg', style, animationClass, onAnimationEnd }) => {
        const sizeClasses = { 
          sm: 'w-16 h-28', // For slots
          md: 'w-20 h-36', // For shuffling card
          lg: 'w-48 h-[21rem] md:w-56 md:h-96' // For result cards
        };
        const iconSizeClasses = { sm: 'w-8 h-8', md: 'w-10 h-10', lg: 'w-16 h-16' };
        return (
          <div 
              className={`cursor-pointer group transition-transform duration-300 ${isSelected ? '-translate-y-2' : ''} ${animationClass || ''}`}
              onClick={onClick}
              style={style}
              onAnimationEnd={onAnimationEnd}
          >
            <div className={`${sizeClasses[size]} [perspective:1000px]`}>
              <div className={`relative w-full h-full transition-transform duration-700 [transform-style:preserve-3d] ${isRevealed ? '[transform:rotateY(180deg)]' : ''} ${isSelected && !isRevealed ? 'ring-4 ring-purple-400 rounded-lg' : ''}`}>
                <div className="absolute w-full h-full [backface-visibility:hidden] rounded-lg bg-indigo-900 border-2 border-purple-400/50 shadow-lg shadow-purple-900/50 flex items-center justify-center overflow-hidden">
                  <div className="absolute w-full h-full bg-[radial-gradient(ellipse_at_center,_rgba(255,255,255,0.1)_0%,_rgba(255,255,255,0)_60%)]"></div>
                  <svg xmlns="http://www.w3.org/2000/svg" className={`${iconSizeClasses[size]} text-purple-400 opacity-50`} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 2 L15.09 8.26 L22 9.27 L17 14.14 L18.18 21.02 L12 17.77 L5.82 21.02 L7 14.14 L2 9.27 L8.91 8.26 L12 2 z"/>
                  </svg>
                </div>
                <div className="absolute w-full h-full [backface-visibility:hidden] [transform:rotateY(180deg)] rounded-lg overflow-hidden shadow-2xl shadow-purple-500/40">
                  <img src={card.url} alt={card.name} className="w-full h-full object-cover" />
                  <div className={`absolute bottom-0 left-0 right-0 p-2 bg-black/60 text-center ${size === 'sm' || size === 'md' ? 'hidden' : ''}`}>
                    <p className="text-white text-xs sm:text-sm font-semibold truncate">{card.name}</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- From App.tsx ---
      const App = () => {
        const [gameState, setGameState] = useState('question');
        const [question, setQuestion] = useState('');
        const [deck, setDeck] = useState([]);
        const [selectedCards, setSelectedCards] = useState([]);
        const [shufflingCard, setShufflingCard] = useState(null);
        const [animationCards, setAnimationCards] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);
        const [isAnimating, setIsAnimating] = useState(false);
        const [flyingCard, setFlyingCard] = useState(null);
        const [interpretation, setInterpretation] = useState(null);
        const [isReadingLoading, setIsReadingLoading] = useState(false);
        const [readingError, setReadingError] = useState(null);
        const shuffleIntervalRef = useRef(null);

        const shuffleArray = (array) => {
          const newArray = [...array];
          for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
          }
          return newArray;
        };

        const setupDeck = useCallback(() => {
          setIsLoading(true);
          setError(null);
          try {
            const allCards = TAROT_CARD_DEFINITIONS.map((def, index) => ({
              id: index,
              name: def.name_ko,
              name_en: def.name_en,
              url: getCardImageUrl(index, def.name_en),
            }));
            setDeck(shuffleArray(allCards));
          } catch (err) {
            console.error("Error setting up deck:", err);
            setError("카드를 준비할 수 없습니다. 연결을 확인하고 다시 시도해주세요.");
          } finally {
            setIsLoading(false);
          }
        }, []);

        useEffect(() => {
          setupDeck();
        }, [setupDeck]);

        const startShuffling = useCallback(() => {
          if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
          shuffleIntervalRef.current = window.setInterval(() => {
            if (deck.length > 0) {
              const shuffledSlice = shuffleArray(deck).slice(0, 5);
              const newAnimationCards = shuffledSlice.map((card, index) => {
                const rotation = Math.random() * 8 - 4;
                const offsetX = Math.random() * 8 - 4;
                const offsetY = Math.random() * 8 - 4;
                return {
                  card,
                  style: { transform: `rotate(${rotation}deg) translate(${offsetX}px, ${offsetY}px)`, zIndex: index, transition: 'transform 0.1s ease-out' },
                };
              });
              setAnimationCards(newAnimationCards);
              if (shuffledSlice.length > 0) setShufflingCard(shuffledSlice[0]);
            }
          }, 100);
        }, [deck]);

        useEffect(() => {
          if (gameState === 'shuffling' && selectedCards.length < 3 && !isAnimating) {
            startShuffling();
          } else {
            if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
          }
          return () => {
            if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
          };
        }, [gameState, selectedCards.length, startShuffling, isAnimating]);
        
        const getInterpretation = useCallback(async () => {
            if (selectedCards.length !== 3 || !question) return;

            setIsReadingLoading(true);
            setReadingError(null);
            setInterpretation(null);
            
            try {
                const response = await fetch(
                    `${SUPABASE_URL}/functions/v1/get-tarot-reading`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            question: question,
                            cards: selectedCards.map(c => ({ name: c.name, name_en: c.name_en })),
                        }),
                    }
                );
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || '해석을 불러오는 데 실패했습니다.');
                }

                const data = await response.json();
                setInterpretation(data);

            } catch (err) {
                console.error("Interpretation Error:", err);
                setReadingError(err.message || '알 수 없는 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
            } finally {
                setIsReadingLoading(false);
            }
        }, [question, selectedCards]);

        useEffect(() => {
          if (gameState === 'results' && selectedCards.length === 3 && !interpretation) {
            getInterpretation();
          }
        }, [gameState, selectedCards, interpretation, getInterpretation]);

        const handleQuestionSubmit = (e) => {
          e.preventDefault();
          if (question.trim()) setGameState('shuffling');
        };

        const handleSelectCard = () => {
          if (shufflingCard && selectedCards.length < 3 && !isAnimating) {
            if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
            setIsAnimating(true);
            setFlyingCard(shufflingCard);
          }
        };

        const handleAnimationEnd = () => {
          if (flyingCard) {
            const newSelectedCards = [...selectedCards, flyingCard];
            setSelectedCards(newSelectedCards);
            setDeck(prevDeck => prevDeck.filter(card => card.id !== flyingCard.id));
            setFlyingCard(null);
            setIsAnimating(false);
            if (newSelectedCards.length === 3) setGameState('results');
          }
        };

        const handleReset = () => {
          setQuestion('');
          setSelectedCards([]);
          setGameState('question');
          setAnimationCards([]);
          setIsAnimating(false);
          setFlyingCard(null);
          setInterpretation(null);
          setIsReadingLoading(false);
          setReadingError(null);
          setupDeck();
        };

        const getShufflePrompt = () => {
          if (isAnimating) return "카드를 배치하는 중...";
          switch (selectedCards.length) {
            case 0: return "첫번째 카드를 뽑기 위해 '선택' 버튼을 눌러주세요.";
            case 1: return "두번째 카드를 뽑기 위해 '선택' 버튼을 눌러주세요.";
            case 2: return "세번째 카드를 뽑기 위해 '선택' 버튼을 눌러주세요.";
            default: return "";
          }
        };

        const renderContent = () => {
          if (isLoading) return <LoadingSpinner size="lg" className="my-24" />;
          if (error) return (
            <div className="text-center my-24 p-8 bg-red-900/20 border border-red-500/50 rounded-lg">
              <p className="text-red-400 text-xl">{error}</p>
              <button onClick={setupDeck} className="mt-6 px-6 py-2 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition-all">다시 시도</button>
            </div>
          );

          switch (gameState) {
            case 'question': return (
              <form onSubmit={handleQuestionSubmit} className="w-full max-w-lg flex flex-col items-center">
                <h2 className="text-xl sm:text-2xl text-indigo-200 mb-4 text-center">어떤 질문을 가지고 계신가요?</h2>
                <textarea value={question} onChange={(e) => setQuestion(e.target.value)} placeholder="예: 저의 연애운은 어떨까요?" className="w-full h-32 p-4 bg-gray-800/50 border-2 border-purple-400/50 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-400" />
                <button type="submit" disabled={!question.trim()} className="mt-6 px-8 py-3 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition-all duration-300 transform hover:scale-105 disabled:bg-gray-500 disabled:cursor-not-allowed disabled:scale-100">카드 섞기</button>
              </form>
            );
            case 'shuffling': return (
              <div className="flex flex-col items-center justify-center w-full gap-8">
                {/* Top Section: Shuffling */}
                <div className="flex flex-col items-center">
                  <p className="text-lg sm:text-xl text-indigo-200 mb-4 h-8 text-center">{getShufflePrompt()}</p>
                  <div className="relative h-40 w-24 md:h-44 md:w-28 flex items-center justify-center">
                    {!isAnimating && animationCards.map(({ card, style }, index) => (
                      <div key={`${card.id}-${index}`} className="absolute">
                        <TarotCard card={card} isRevealed={false} size="md" style={style} />
                      </div>
                    ))}
                    {flyingCard && (
                      <div className="absolute z-50">
                        <TarotCard card={flyingCard} isRevealed={false} size="md" animationClass={`animate-fly-slot-${selectedCards.length}`} onAnimationEnd={handleAnimationEnd} />
                      </div>
                    )}
                  </div>
                  <button onClick={handleSelectCard} disabled={isAnimating} className="mt-6 px-12 py-4 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition-all duration-300 transform hover:scale-105 disabled:bg-gray-500 disabled:cursor-not-allowed disabled:scale-100">선택</button>
                </div>
                {/* Bottom Section: Slots */}
                <div className="flex flex-row gap-4 pt-4">
                  {Array.from({ length: 3 }).map((_, index) => (
                    <div key={index} className="w-16 h-28 rounded-lg bg-indigo-900/50 border-2 border-dashed border-purple-400/30 flex items-center justify-center">
                      {selectedCards[index] && <TarotCard card={selectedCards[index]} isRevealed={true} size="sm" />}
                    </div>
                  ))}
                </div>
              </div>
            );
            case 'results': return (
              <div className="flex flex-col items-center w-full">
                <div className="mb-6 sm:mb-8 text-center p-4 bg-black/20 rounded-lg w-full max-w-2xl">
                  <p className="text-base sm:text-lg text-indigo-200">질문:</p>
                  <p className="text-lg sm:text-xl font-semibold">{question}</p>
                </div>
                <div className="mb-8 w-full grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-10 items-start justify-center place-items-center">
                  {selectedCards.map((card, index) => (
                    <div key={card.id} className="flex flex-col items-center">
                      <p className="text-lg font-bold text-purple-300 mb-2">{['과거', '현재', '미래'][index]}</p>
                      <TarotCard card={card} isRevealed={true} size="lg" />
                    </div>
                  ))}
                </div>

                <div className="mt-4 w-full max-w-3xl">
                    {isReadingLoading && (
                        <div className="flex flex-col items-center gap-4 p-8 bg-black/20 rounded-lg">
                        <LoadingSpinner />
                        <p className="text-indigo-200 animate-pulse">당신의 운세를 해석하는 중...</p>
                        </div>
                    )}
                    {readingError && (
                        <div className="text-center p-8 bg-red-900/20 border border-red-500/50 rounded-lg">
                        <p className="text-red-400 text-xl mb-4">{readingError}</p>
                        <button onClick={getInterpretation} className="px-6 py-2 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition-all">
                            해석 재시도
                        </button>
                        </div>
                    )}
                    {interpretation && (
                        <div className="space-y-6 text-left p-6 md:p-8 bg-indigo-950/40 border border-purple-500/20 rounded-xl shadow-2xl shadow-purple-900/20">
                            <div>
                                <h3 className="text-xl font-bold text-purple-300 mb-2 border-b-2 border-purple-400/30 pb-2">과거 (첫번째 카드)</h3>
                                <p className="text-indigo-100 whitespace-pre-wrap leading-relaxed">{interpretation.past}</p>
                            </div>
                            <div>
                                <h3 className="text-xl font-bold text-purple-300 mb-2 border-b-2 border-purple-400/30 pb-2">현재 (두번째 카드)</h3>
                                <p className="text-indigo-100 whitespace-pre-wrap leading-relaxed">{interpretation.present}</p>
                            </div>
                            <div>
                                <h3 className="text-xl font-bold text-purple-300 mb-2 border-b-2 border-purple-400/30 pb-2">미래 (세번째 카드)</h3>
                                <p className="text-indigo-100 whitespace-pre-wrap leading-relaxed">{interpretation.future}</p>
                            </div>
                             <div>
                                <h3 className="text-xl font-bold text-green-300 mb-2 border-b-2 border-green-400/30 pb-2">총운 및 조언</h3>
                                <p className="text-indigo-100 whitespace-pre-wrap leading-relaxed">{interpretation.summary}</p>
                            </div>
                        </div>
                    )}
                </div>

                <button onClick={handleReset} className="mt-12 px-8 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition-all duration-300 transform hover:scale-105">새로운 리딩 시작하기</button>
              </div>
            );
          }
        };

        return (
          <div className="min-h-screen bg-gradient-to-b from-gray-900 via-indigo-950 to-black text-white font-sans p-4 sm:p-8 flex flex-col items-center">
            <header className="text-center mb-6 w-full">
              <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-300 tracking-wider">Taro</h1>
              {gameState !== 'question' && <p className="text-indigo-200 mt-2 text-sm sm:text-base">당신의 직관이 이끄는대로 선택하세요.</p>}
            </header>
            <main className="w-full max-w-screen-xl flex flex-col items-center justify-center flex-grow">{renderContent()}</main>
            <footer className="text-center text-gray-500 mt-auto text-sm pt-8"><p>타로 리딩은 오락용으로만 즐겨주세요.</p></footer>
          </div>
        );
      };

      // --- From index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
</body>
</html>