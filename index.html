<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Taro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Babel Standalone for in-browser JSX/TSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="importmap">
{
  "imports": {
    "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
    "react": "https://esm.sh/react@^18.2.0",
    "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@^2.55.0",
    "react-dom/": "https://esm.sh/react-dom@^19.1.1/",
    "react/": "https://esm.sh/react@^19.1.1/"
  }
}
</script>
<style>
  /* Unified Top-to-Bottom Animations for All Screens */
  @keyframes fly-to-slot-0 { /* To left slot */
      from { transform: translate(0, 0) rotateY(0deg) scale(1); opacity: 1; }
      50% { transform: translate(-40px, 120px) rotateY(90deg) scale(0.9); }
      to { transform: translate(-80px, 240px) rotateY(180deg) scale(0.8); opacity: 0; }
  }
  @keyframes fly-to-slot-1 { /* To middle slot */
      from { transform: translate(0, 0) rotateY(0deg) scale(1); opacity: 1; }
      50% { transform: translate(0, 120px) rotateY(90deg) scale(0.9); }
      to { transform: translate(0, 240px) rotateY(180deg) scale(0.8); opacity: 0; }
  }
  @keyframes fly-to-slot-2 { /* To right slot */
      from { transform: translate(0, 0) rotateY(0deg) scale(1); opacity: 1; }
      50% { transform: translate(40px, 120px) rotateY(90deg) scale(0.9); }
      to { transform: translate(80px, 240px) rotateY(180deg) scale(0.8); opacity: 0; }
  }

  .animate-fly-slot-0 { animation: fly-to-slot-0 1.2s ease-in-out forwards; }
  .animate-fly-slot-1 { animation: fly-to-slot-1 1.2s ease-in-out forwards; }
  .animate-fly-slot-2 { animation: fly-to-slot-2 1.2s ease-in-out forwards; }

  /* Staggered entry animation for result cards */
  @keyframes card-entry {
    from {
      opacity: 0;
      transform: translateY(30px) scale(0.95);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  .animate-card-entry {
    animation: card-entry 0.7s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    opacity: 0; /* Start hidden */
  }
  
  /* Fade in animation for interpretation text */
  @keyframes fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .animate-fade-in {
    animation: fade-in 1s ease-in-out forwards;
  }

  /* Typing effect cursor */
  @keyframes blink-caret { from, to { border-color: transparent } 50% { border-color: #a78bfa; } }
  .typing-cursor::after {
      content: '';
      display: inline-block;
      width: 1px;
      height: 1.2em;
      margin-left: 0.25em;
      border-right: 2px solid #a78bfa;
      animation: blink-caret .75s step-end infinite;
      vertical-align: bottom;
  }
</style>
</head>
<body class="bg-gray-900">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { createClient } from '@supabase/supabase-js';

      // --- From types.ts ---
      interface TarotCardData {
        id: number;
        name: string; // Korean name for display
        name_en: string; // English name for image URL
        url: string;
      }

      // --- From constants.ts ---
      const SUPABASE_URL = 'https://xkwzpjsbvcilghdsgsld.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhrd3pwanNidmNpbGdoZHNnc2xkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNDgyNTksImV4cCI6MjA3MDgyNDI1OX0.YCO3I8oy4iAYEiHt7BYMDhJIodgq3T0mqdMcEszGtvU';
      const BUCKET_NAME = 'taro_image';
      const TAROT_CARD_DEFINITIONS = [
        { name_en: "The Fool", name_ko: "바보" }, { name_en: "The Magician", name_ko: "마법사" }, { name_en: "The High Priestess", name_ko: "여사제" }, { name_en: "The Empress", name_ko: "여황제" }, { name_en: "The Emperor", name_ko: "황제" }, { name_en: "The Hierophant", name_ko: "교황" }, { name_en: "The Lovers", name_ko: "연인" }, { name_en: "The Chariot", name_ko: "전차" }, { name_en: "Strength", name_ko: "힘" }, { name_en: "The Hermit", name_ko: "은둔자" }, { name_en: "Wheel of Fortune", name_ko: "운명의 수레바퀴" }, { name_en: "Justice", name_ko: "정의" }, { name_en: "The Hanged Man", name_ko: "매달린 남자" }, { name_en: "Death", name_ko: "죽음" }, { name_en: "Temperance", name_ko: "절제" }, { name_en: "The Devil", name_ko: "악마" }, { name_en: "The Tower", name_ko: "탑" }, { name_en: "The Star", name_ko: "별" }, { name_en: "The Moon", name_ko: "달" }, { name_en: "The Sun", name_ko: "태양" }, { name_en: "Judgement", name_ko: "심판" }, { name_en: "The World", name_ko: "세계" },
        { name_en: "Ace of Wands", name_ko: "완드 에이스" }, { name_en: "Two of Wands", name_ko: "완드 2" }, { name_en: "Three of Wands", name_ko: "완드 3" }, { name_en: "Four of Wands", name_ko: "완드 4" }, { name_en: "Five of Wands", name_ko: "완드 5" }, { name_en: "Six of Wands", name_ko: "완드 6" }, { name_en: "Seven of Wands", name_ko: "완드 7" }, { name_en: "Eight of Wands", name_ko: "완드 8" }, { name_en: "Nine of Wands", name_ko: "완드 9" }, { name_en: "Ten of Wands", name_ko: "완드 10" }, { name_en: "Page of Wands", name_ko: "완드 페이지" }, { name_en: "Knight of Wands", name_ko: "완드 나이트" }, { name_en: "Queen of Wands", name_ko: "완드 퀸" }, { name_en: "King of Wands", name_ko: "완드 킹" },
        { name_en: "Ace of Cups", name_ko: "컵 에이스" }, { name_en: "Two of Cups", name_ko: "컵 2" }, { name_en: "Three of Cups", name_ko: "컵 3" }, { name_en: "Four of Cups", name_ko: "컵 4" }, { name_en: "Five of Cups", name_ko: "컵 5" }, { name_en: "Six of Cups", name_ko: "컵 6" }, { name_en: "Seven of Cups", name_ko: "컵 7" }, { name_en: "Eight of Cups", name_ko: "컵 8" }, { name_en: "Nine of Cups", name_ko: "컵 9" }, { name_en: "Ten of Cups", name_ko: "컵 10" }, { name_en: "Page of Cups", name_ko: "컵 페이지" }, { name_en: "Knight of Cups", name_ko: "컵 나이트" }, { name_en: "Queen of Cups", name_ko: "컵 퀸" }, { name_en: "King of Cups", name_ko: "컵 킹" },
        { name_en: "Ace of Swords", name_ko: "소드 에이스" }, { name_en: "Two of Swords", name_ko: "소드 2" }, { name_en: "Three of Swords", name_ko: "소드 3" }, { name_en: "Four of Swords", name_ko: "소드 4" }, { name_en: "Five of Swords", name_ko: "소드 5" }, { name_en: "Six of Swords", name_ko: "소드 6" }, { name_en: "Seven of Swords", name_ko: "소드 7" }, { name_en: "Eight of Swords", name_ko: "소드 8" }, { name_en: "Nine of Swords", name_ko: "소드 9" }, { name_en: "Ten of Swords", name_ko: "소드 10" }, { name_en: "Page of Swords", name_ko: "소드 페이지" }, { name_en: "Knight of Swords", name_ko: "소드 나이트" }, { name_en: "Queen of Swords", name_ko: "소드 퀸" }, { name_en: "King of Swords", name_ko: "소드 킹" },
        { name_en: "Ace of Pentacles", name_ko: "펜타클 에이스" }, { name_en: "Two of Pentacles", name_ko: "펜타클 2" }, { name_en: "Three of Pentacles", name_ko: "펜타클 3" }, { name_en: "Four of Pentacles", name_ko: "펜타클 4" }, { name_en: "Five of Pentacles", name_ko: "펜타클 5" }, { name_en: "Six of Pentacles", name_ko: "펜타클 6" }, { name_en: "Seven of Pentacles", name_ko: "펜타클 7" }, { name_en: "Eight of Pentacles", name_ko: "펜타클 8" }, { name_en: "Nine of Pentacles", name_ko: "펜타클 9" }, { name_en: "Ten of Pentacles", name_ko: "펜타클 10" }, { name_en: "Page of Pentacles", name_ko: "펜타클 페이지" }, { name_en: "Knight of Pentacles", name_ko: "펜타클 나이트" }, { name_en: "Queen of Pentacles", name_ko: "펜타클 퀸" }, { name_en: "King of Pentacles", name_ko: "펜타클 킹" }
      ];

      // --- From services/supabaseService.ts ---
      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      function getCardImageUrl(cardId, cardName) {
        const fileName = `${cardName.trim().replace(/\s+/g, '_')}.png`;
        const imagePath = `cards/${fileName}`;
        const { data } = supabase.storage.from(BUCKET_NAME).getPublicUrl(imagePath);
        if (!data.publicUrl) {
          console.error(`Could not get public URL for path: ${imagePath}.`);
          return `https://picsum.photos/400/600?random=${cardId}`;
        }
        return data.publicUrl;
      }

      // --- From components/ParticleCanvas.tsx ---
      const ParticleCanvas = () => {
        const canvasRef = useRef(null);
        const particlesRef = useRef([]);
        const mousePosRef = useRef({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
        const animationFrameIdRef = useRef(null);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');

          const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          };

          const handleMouseMove = (e) => {
            mousePosRef.current = { x: e.clientX, y: e.clientY };
          };

          window.addEventListener('resize', resizeCanvas);
          document.addEventListener('mousemove', handleMouseMove, { passive: true });
          resizeCanvas();

          const createParticle = () => {
            if (document.hidden) return;
            const x = mousePosRef.current.x;
            const y = mousePosRef.current.y;
            const size = Math.random() * 1.5 + 0.5;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 1.0 + 0.2;
            const speedX = Math.cos(angle) * speed;
            const speedY = Math.sin(angle) * speed;
            const life = Math.random() * 60 + 50;
            const color = ['#FFFFFF', '#E0D8FF', '#C7B2FF'][Math.floor(Math.random() * 3)];
            particlesRef.current.push({ x, y, size, speedX, speedY, life, maxLife: life, color });
          };

          const animate = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (particlesRef.current.length < 150) {
              createParticle();
            }
            for (let i = particlesRef.current.length - 1; i >= 0; i--) {
              const p = particlesRef.current[i];
              p.x += p.speedX;
              p.y += p.speedY;
              p.life -= 1;
              if (p.life <= 0) {
                particlesRef.current.splice(i, 1);
                continue;
              }
              const opacity = Math.max(0, p.life / p.maxLife - 0.1);
              ctx.beginPath();
              ctx.rect(p.x, p.y, p.size, p.size);
              const r = parseInt(p.color.slice(1, 3), 16);
              const g = parseInt(p.color.slice(3, 5), 16);
              const b = parseInt(p.color.slice(5, 7), 16);
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
              ctx.fill();
            }
            animationFrameIdRef.current = requestAnimationFrame(animate);
          };

          animate();

          return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('resize', resizeCanvas);
            if (animationFrameIdRef.current) {
              cancelAnimationFrame(animationFrameIdRef.current);
            }
          };
        }, []);

        return (
          <canvas 
            ref={canvasRef} 
            className="fixed top-0 left-0 w-full h-full pointer-events-none z-50"
          />
        );
      };

      // --- From components/CardBurstParticles.tsx ---
      const CardBurstParticles = ({ isBursting }) => {
          const canvasRef = useRef(null);
          const animationFrameIdRef = useRef(null);
          const particlesRef = useRef([]);

          useEffect(() => {
              const canvas = canvasRef.current;
              if (!canvas || !isBursting) return;
              
              const ctx = canvas.getContext('2d');
              canvas.width = 300; 
              canvas.height = 500;
              particlesRef.current = [];

              const createParticle = (i) => {
                  const x = canvas.width / 2;
                  const y = canvas.height / 2;
                  const angle = (i / 50) * Math.PI * 2;
                  const speed = Math.random() * 4 + 2;
                  const size = Math.random() * 3 + 1;
                  const life = Math.random() * 60 + 30;
                  const color = Math.random() > 0.3 ? '#FFD700' : '#E6E6FA'; // Gold and Lavender
                  return { x, y, size, speedX: Math.cos(angle) * speed, speedY: Math.sin(angle) * speed, life, maxLife: life, color };
              };
              
              for (let i = 0; i < 50; i++) {
                  particlesRef.current.push(createParticle(i));
              }

              const animate = () => {
                  if (!canvas) return;
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  for (let i = particlesRef.current.length - 1; i >= 0; i--) {
                      const p = particlesRef.current[i];
                      p.x += p.speedX;
                      p.y += p.speedY;
                      p.life -= 1;

                      if (p.life <= 0) {
                          particlesRef.current.splice(i, 1);
                          continue;
                      }
                      const opacity = Math.max(0, p.life / p.maxLife);
                      ctx.globalAlpha = opacity;
                      ctx.beginPath();
                      ctx.fillStyle = p.color;
                      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2, false);
                      ctx.fill();
                  }

                  if (particlesRef.current.length > 0) {
                      animationFrameIdRef.current = requestAnimationFrame(animate);
                  } else {
                      ctx.clearRect(0, 0, canvas.width, canvas.height);
                  }
              };
              
              animate();

              return () => {
                  if (animationFrameIdRef.current) cancelAnimationFrame(animationFrameIdRef.current);
              };
          }, [isBursting]);

          return (
              <canvas 
                  ref={canvasRef}
                  className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[150%] h-[130%] pointer-events-none z-10"
              />
          );
      };

      // --- From components/LoadingSpinner.tsx ---
      const LoadingSpinner = ({ size = 'md', className = '' }) => {
        const sizeClasses = { sm: 'w-6 h-6', md: 'w-10 h-10', lg: 'w-16 h-16' };
        return (
          <div className={`flex justify-center items-center ${className}`}>
            <div className={`animate-spin rounded-full ${sizeClasses[size]} border-t-2 border-b-2 border-purple-400`}></div>
          </div>
        );
      };

      // --- From components/TarotCard.tsx ---
      const TarotCard = ({ card, isRevealed, isSelected = false, onClick, size = 'lg', style, animationClass, onAnimationEnd }) => {
        const sizeClasses = { 
          sm: 'w-16 h-28', // For slots
          md: 'w-20 h-36', // For shuffling card
          lg: 'w-48 h-[21rem] md:w-56 md:h-96' // For result cards
        };
        const iconSizeClasses = { sm: 'w-8 h-8', md: 'w-10 h-10', lg: 'w-16 h-16' };
        
        const cardRef = useRef(null);

        // This logic should only apply to the large, revealed result cards for the best effect.
        const isInteractive = size === 'lg' && isRevealed;

        const handleMouseMove = (e) => {
            if (!isInteractive || !cardRef.current) return;

            const { left, top, width, height } = cardRef.current.getBoundingClientRect();
            const x = e.clientX - left;
            const y = e.clientY - top;
            
            const rotateX = -1 * ((y - height / 2) / (height / 2)) * 12; // Max 12 deg tilt
            const rotateY = ((x - width / 2) / (width / 2)) * 12;

            // Apply the transform to the card's container. The flip animation is on a child, so it will inherit this transform.
            cardRef.current.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.05)`;
            cardRef.current.style.transition = 'transform 0.05s ease-out';
        };

        const handleMouseLeave = () => {
            if (!isInteractive || !cardRef.current) return;

            // Reset transform on mouse leave.
            cardRef.current.style.transform = 'rotateX(0deg) rotateY(0deg) scale(1)';
            cardRef.current.style.transition = 'transform 0.6s cubic-bezier(0.23, 1, 0.32, 1)';
        };
        
        return (
          <div 
              className={`cursor-pointer group transition-transform duration-300 ${isSelected ? '-translate-y-2' : ''} ${animationClass || ''}`}
              onClick={onClick}
              style={style}
              onAnimationEnd={onAnimationEnd}
          >
            <div 
              ref={cardRef}
              className={`${sizeClasses[size]} [perspective:1000px]`}
              onMouseMove={isInteractive ? handleMouseMove : null}
              onMouseLeave={isInteractive ? handleMouseLeave : null}
            >
              <div className={`relative w-full h-full transition-transform duration-700 [transform-style:preserve-3d] ${isRevealed ? '[transform:rotateY(180deg)]' : ''} ${isSelected && !isRevealed ? 'ring-4 ring-purple-400 rounded-lg' : ''}`}>
                <div className="absolute w-full h-full [backface-visibility:hidden] rounded-lg bg-indigo-900 border-2 border-purple-400/50 shadow-lg shadow-purple-900/50 flex items-center justify-center overflow-hidden">
                  <div className="absolute w-full h-full bg-[radial-gradient(ellipse_at_center,_rgba(255,255,255,0.1)_0%,_rgba(255,255,255,0)_60%)]"></div>
                  <svg xmlns="http://www.w3.org/2000/svg" className={`${iconSizeClasses[size]} text-purple-400 opacity-50`} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 2 L15.09 8.26 L22 9.27 L17 14.14 L18.18 21.02 L12 17.77 L5.82 21.02 L7 14.14 L2 9.27 L8.91 8.26 L12 2 z"/>
                  </svg>
                </div>
                <div className="absolute w-full h-full [backface-visibility:hidden] [transform:rotateY(180deg)] rounded-lg overflow-hidden shadow-2xl shadow-purple-500/40">
                  <img src={card.url} alt={card.name} className="w-full h-full object-cover" />
                  <div className={`absolute bottom-0 left-0 right-0 p-2 bg-black/60 text-center ${size === 'sm' || size === 'md' ? 'hidden' : ''}`}>
                    <p className="text-white text-xs sm:text-sm font-semibold truncate">{card.name}</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- From App.tsx ---
      const App = () => {
        const [gameState, setGameState] = useState('question');
        const [question, setQuestion] = useState('');
        const [deck, setDeck] = useState([]);
        const [selectedCards, setSelectedCards] = useState([]);
        const [shufflingCard, setShufflingCard] = useState(null);
        const [animationCards, setAnimationCards] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);
        const [isAnimating, setIsAnimating] = useState(false);
        const [flyingCard, setFlyingCard] = useState(null);
        const [interpretation, setInterpretation] = useState(null);
        const [isReadingLoading, setIsReadingLoading] = useState(false);
        const [readingError, setReadingError] = useState(null);
        const [burstState, setBurstState] = useState([false, false, false]);
        const [typedInterpretation, setTypedInterpretation] = useState({ past: '', present: '', future: '', summary: '' });
        const [currentTypingKey, setCurrentTypingKey] = useState(null);
        const [placeholder, setPlaceholder] = useState("예: 저의 연애운은 어떨까요?");
        const [isPlaceholderFading, setIsPlaceholderFading] = useState(false);
        
        const shuffleIntervalRef = useRef(null);
        const typingIntervalRef = useRef(null);
        const placeholderIntervalRef = useRef(null);
        const audioContextRef = useRef(null);

        const playSound = useCallback((type) => {
            if (!audioContextRef.current) return;
            const context = audioContextRef.current;
            
            if (type === 'flip') {
                const bufferSize = context.sampleRate * 0.5;
                const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
                const output = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                const noise = context.createBufferSource();
                noise.buffer = buffer;

                const bandpass = context.createBiquadFilter();
                bandpass.type = 'bandpass';
                bandpass.frequency.setValueAtTime(1500, context.currentTime);
                bandpass.Q.setValueAtTime(10, context.currentTime);

                const gain = context.createGain();
                gain.gain.setValueAtTime(0.3, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 0.5);

                noise.connect(bandpass).connect(gain).connect(context.destination);
                noise.start();
                noise.stop(context.currentTime + 0.5);
            } else if (type === 'complete') {
                const oscillator = context.createOscillator();
                const gain = context.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, context.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(1046.50, context.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.2, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 0.3);

                oscillator.connect(gain).connect(context.destination);
                oscillator.start();
                oscillator.stop(context.currentTime + 0.3);
            }
        }, []);

        const shuffleArray = (array) => {
          const newArray = [...array];
          for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
          }
          return newArray;
        };

        const setupDeck = useCallback(() => {
          setIsLoading(true);
          setError(null);
          try {
            const allCards = TAROT_CARD_DEFINITIONS.map((def, index) => ({
              id: index,
              name: def.name_ko,
              name_en: def.name_en,
              url: getCardImageUrl(index, def.name_en),
            }));
            setDeck(shuffleArray(allCards));
          } catch (err) {
            console.error("Error setting up deck:", err);
            setError("카드를 준비할 수 없습니다. 연결을 확인하고 다시 시도해주세요.");
          } finally {
            setIsLoading(false);
          }
        }, []);

        useEffect(() => {
          setupDeck();
        }, [setupDeck]);

        const startShuffling = useCallback(() => {
          if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
          shuffleIntervalRef.current = window.setInterval(() => {
            if (deck.length > 0) {
              const shuffledSlice = shuffleArray(deck).slice(0, 5);
              const newAnimationCards = shuffledSlice.map((card, index) => {
                const rotation = Math.random() * 8 - 4;
                const offsetX = Math.random() * 8 - 4;
                const offsetY = Math.random() * 8 - 4;
                return {
                  card,
                  style: { transform: `rotate(${rotation}deg) translate(${offsetX}px, ${offsetY}px)`, zIndex: index, transition: 'transform 0.1s ease-out' },
                };
              });
              setAnimationCards(newAnimationCards);
              if (shuffledSlice.length > 0) setShufflingCard(shuffledSlice[0]);
            }
          }, 100);
        }, [deck]);

        useEffect(() => {
          if (gameState === 'shuffling' && selectedCards.length < 3 && !isAnimating) {
            startShuffling();
          } else {
            if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
          }
          return () => {
            if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
          };
        }, [gameState, selectedCards.length, startShuffling, isAnimating]);
        
        const getInterpretation = useCallback(async () => {
            if (selectedCards.length !== 3 || !question) return;

            setIsReadingLoading(true);
            setReadingError(null);
            setInterpretation(null);
            setTypedInterpretation({ past: '', present: '', future: '', summary: '' });
            setCurrentTypingKey(null);
            
            try {
                const response = await fetch(
                    `${SUPABASE_URL}/functions/v1/get-tarot-reading`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        },
                        body: JSON.stringify({
                            question: question,
                            cards: selectedCards.map(c => ({ name: c.name, name_en: c.name_en })),
                        }),
                    }
                );
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || '해석을 불러오는 데 실패했습니다.');
                }

                const data = await response.json();
                setInterpretation(data);

            } catch (err) {
                console.error("Interpretation Error:", err);
                setReadingError(err.message || '알 수 없는 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
            } finally {
                setIsReadingLoading(false);
            }
        }, [question, selectedCards]);

        useEffect(() => {
          if (gameState === 'results' && selectedCards.length === 3) {
            if (!interpretation && !isReadingLoading && !readingError) {
              getInterpretation();
            }
            // Particle burst and sound logic
            const timeouts = [];
            selectedCards.forEach((_, index) => {
              const timeout = setTimeout(() => {
                setBurstState(prev => {
                  const newState = [...prev];
                  newState[index] = true;
                  return newState;
                });
                playSound('flip');
              }, index * 250 + 400); // Trigger after card entry animation starts
              timeouts.push(timeout);
            });
            return () => timeouts.forEach(clearTimeout);
          }
        }, [gameState, selectedCards, interpretation, getInterpretation, isReadingLoading, readingError, playSound]);

        const formatInterpretationText = (text) => {
            if (!text) return '';
            return text
                .split(/\n+/)
                .filter(paragraph => paragraph.trim() !== '')
                .map(paragraph => `    ${paragraph.trim()}`)
                .join('\n\n');
        };

        // Typing Effect Logic
        useEffect(() => {
            if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);

            if (interpretation && !isReadingLoading && gameState === 'results') {
                const interpretationKeys = ['past', 'present', 'future', 'summary'];
                let keyIndex = 0;

                const startTyping = (key) => {
                    if (!key || !interpretation[key]) {
                        if (keyIndex < interpretationKeys.length - 1) {
                            keyIndex++;
                            startTyping(interpretationKeys[keyIndex]);
                        } else {
                            setCurrentTypingKey(null); 
                            playSound('complete');
                        }
                        return;
                    }
                    
                    setCurrentTypingKey(key);
                    let charIndex = 0;
                    const textToType = formatInterpretationText(interpretation[key]);
                    
                    typingIntervalRef.current = setInterval(() => {
                        if (charIndex < textToType.length) {
                            setTypedInterpretation(prev => ({
                                ...prev,
                                [key]: textToType.substring(0, charIndex + 1)
                            }));
                            charIndex++;
                        } else {
                            clearInterval(typingIntervalRef.current);
                            if (keyIndex < interpretationKeys.length - 1) {
                                keyIndex++;
                                startTyping(interpretationKeys[keyIndex]);
                            } else {
                                setCurrentTypingKey(null);
                                playSound('complete');
                            }
                        }
                    }, 30);
                };

                setTypedInterpretation({ past: '', present: '', future: '', summary: '' });
                startTyping(interpretationKeys[keyIndex]);
            }

            return () => {
                if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
            };
        }, [interpretation, isReadingLoading, gameState, playSound]);

        // Placeholder Rotation Logic
        useEffect(() => {
          if (gameState === 'question') {
            const examplePlaceholders = [
              "예: 저의 연애운은 어떨까요?",
              "예: 이직을 해야 할까요?",
              "예: 새로운 도전을 시작해야 할까요?",
              "예: 금전운은 어떻게 될까요?"
            ];
            let currentIndex = 0;
  
            placeholderIntervalRef.current = setInterval(() => {
              setIsPlaceholderFading(true);
  
              setTimeout(() => {
                currentIndex = (currentIndex + 1) % examplePlaceholders.length;
                setPlaceholder(examplePlaceholders[currentIndex]);
                setIsPlaceholderFading(false);
              }, 500);
            }, 4000);
          } else {
            if (placeholderIntervalRef.current) clearInterval(placeholderIntervalRef.current);
          }
  
          return () => {
            if (placeholderIntervalRef.current) clearInterval(placeholderIntervalRef.current);
          };
        }, [gameState]);

        const handleQuestionSubmit = (e) => {
          e.preventDefault();
          if (!audioContextRef.current) {
              try {
                  audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
              } catch (err) {
                  console.error("Web Audio API is not supported in this browser.");
              }
          }
          if (question.trim()) setGameState('shuffling');
        };

        const handleSelectCard = () => {
          if (shufflingCard && selectedCards.length < 3 && !isAnimating) {
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
            setIsAnimating(true);
            setFlyingCard(shufflingCard);
          }
        };

        const handleAnimationEnd = () => {
          if (flyingCard) {
            const newSelectedCards = [...selectedCards, flyingCard];
            setSelectedCards(newSelectedCards);
            setDeck(prevDeck => prevDeck.filter(card => card.id !== flyingCard.id));
            setFlyingCard(null);
            setIsAnimating(false);
            if (newSelectedCards.length === 3) setGameState('results');
          }
        };

        const handleReset = () => {
          setQuestion('');
          setSelectedCards([]);
          setGameState('question');
          setAnimationCards([]);
          setIsAnimating(false);
          setFlyingCard(null);
          setInterpretation(null);
          setIsReadingLoading(false);
          setReadingError(null);
          setBurstState([false, false, false]);
          setTypedInterpretation({ past: '', present: '', future: '', summary: '' });
          setCurrentTypingKey(null);
          if (typingIntervalRef.current) clearInterval(typingIntervalRef.current);
          setupDeck();
        };

        const getShufflePrompt = () => {
          if (isAnimating) return "카드를 배치하는 중...";
          switch (selectedCards.length) {
            case 0: return "첫번째 카드를 뽑기 위해 '선택' 버튼을 눌러주세요.";
            case 1: return "두번째 카드를 뽑기 위해 '선택' 버튼을 눌러주세요.";
            case 2: return "세번째 카드를 뽑기 위해 '선택' 버튼을 눌러주세요.";
            default: return "";
          }
        };
        
        const renderContent = () => {
          if (isLoading) return <LoadingSpinner size="lg" className="my-24" />;
          if (error) return (
            <div className="text-center my-24 p-8 bg-red-900/20 border border-red-500/50 rounded-lg">
              <p className="text-red-400 text-xl">{error}</p>
              <button onClick={setupDeck} className="mt-6 px-6 py-2 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition-all">다시 시도</button>
            </div>
          );

          switch (gameState) {
            case 'question': return (
              <form onSubmit={handleQuestionSubmit} className="w-full max-w-lg flex flex-col items-center">
                <h2 className="text-xl sm:text-2xl text-indigo-200 mb-4 text-center">어떤 질문을 가지고 계신가요?</h2>
                <textarea 
                  value={question} 
                  onChange={(e) => setQuestion(e.target.value)} 
                  placeholder={placeholder} 
                  className={`w-full h-32 p-4 bg-gray-800/50 border-2 border-purple-400/50 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-purple-400 placeholder:text-gray-400 placeholder:transition-opacity placeholder:duration-500 ${isPlaceholderFading ? 'placeholder:opacity-0' : 'placeholder:opacity-100'}`} />
                <button type="submit" disabled={!question.trim()} className="mt-6 px-8 py-3 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition-all duration-300 transform hover:scale-105 disabled:bg-gray-500 disabled:cursor-not-allowed disabled:scale-100">카드 섞기</button>
              </form>
            );
            case 'shuffling': return (
              <div className="flex flex-col items-center justify-center w-full gap-8">
                {/* Top Section: Shuffling */}
                <div className="flex flex-col items-center">
                  <p className="text-lg sm:text-xl text-indigo-200 mb-4 h-8 text-center">{getShufflePrompt()}</p>
                  <div className="relative h-40 w-24 md:h-44 md:w-28 flex items-center justify-center">
                    {!isAnimating && animationCards.map(({ card, style }, index) => (
                      <div key={`${card.id}-${index}`} className="absolute">
                        <TarotCard card={card} isRevealed={false} size="md" style={style} />
                      </div>
                    ))}
                    {flyingCard && (
                      <div className="absolute z-50">
                        <TarotCard card={flyingCard} isRevealed={false} size="md" animationClass={`animate-fly-slot-${selectedCards.length}`} onAnimationEnd={handleAnimationEnd} />
                      </div>
                    )}
                  </div>
                  <button onClick={handleSelectCard} disabled={isAnimating} className="mt-6 px-12 py-4 bg-purple-600 text-white font-bold rounded-lg shadow-lg hover:bg-purple-700 transition-all duration-300 transform hover:scale-105 disabled:bg-gray-500 disabled:cursor-not-allowed disabled:scale-100">선택</button>
                </div>
                {/* Bottom Section: Slots */}
                <div className="flex flex-row gap-4 pt-4">
                  {Array.from({ length: 3 }).map((_, index) => (
                    <div key={index} className="w-16 h-28 rounded-lg bg-indigo-900/50 border-2 border-dashed border-purple-400/30 flex items-center justify-center">
                      {selectedCards[index] && <TarotCard card={selectedCards[index]} isRevealed={true} size="sm" />}
                    </div>
                  ))}
                </div>
              </div>
            );
            case 'results': return (
              <div className="flex flex-col items-center w-full">
                <div className="mb-6 sm:mb-8 text-center p-4 bg-black/20 rounded-lg w-full max-w-2xl">
                  <p className="text-base sm:text-lg text-indigo-200">질문:</p>
                  <p className="text-lg sm:text-xl font-semibold">{question}</p>
                </div>
                <div className="mb-8 w-full grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-10 items-start justify-center place-items-center">
                  {selectedCards.map((card, index) => (
                    <div 
                      key={card.id} 
                      className="relative flex flex-col items-center animate-card-entry"
                      style={{ animationDelay: `${index * 250}ms` }}
                    >
                      <p className="text-lg font-bold text-purple-300 mb-2">{['과거', '현재', '미래'][index]}</p>
                      <CardBurstParticles isBursting={burstState[index]} />
                      <TarotCard card={card} isRevealed={true} size="lg" />
                    </div>
                  ))}
                </div>

                <div className="mt-4 w-full max-w-3xl">
                    {isReadingLoading && (
                        <div className="flex flex-col items-center gap-4 p-8 bg-black/20 rounded-lg">
                        <LoadingSpinner />
                        <p className="text-indigo-200 animate-pulse">당신의 운세를 해석하는 중...</p>
                        </div>
                    )}
                    {readingError && (
                        <div className="text-center p-8 bg-red-900/20 border border-red-500/50 rounded-lg">
                        <p className="text-red-400 text-xl mb-4">{readingError}</p>
                        <button onClick={getInterpretation} className="px-6 py-2 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition-all">
                            해석 재시도
                        </button>
                        </div>
                    )}
                    {interpretation && (
                        <div className="space-y-6 text-left p-6 md:p-8 bg-indigo-950/40 border border-purple-500/20 rounded-xl shadow-2xl shadow-purple-900/20">
                            {(typedInterpretation.past || currentTypingKey === 'past') && (
                                <div className="animate-fade-in">
                                    <h3 className="text-xl font-bold text-purple-300 mb-2 border-b-2 border-purple-400/30 pb-2">과거 (첫번째 카드)</h3>
                                    <p className={`text-indigo-100 whitespace-pre-wrap leading-relaxed ${currentTypingKey === 'past' ? 'typing-cursor' : ''}`}>{typedInterpretation.past}</p>
                                </div>
                            )}
                            {(typedInterpretation.present || currentTypingKey === 'present') && (
                                <div className="animate-fade-in">
                                    <h3 className="text-xl font-bold text-purple-300 mb-2 border-b-2 border-purple-400/30 pb-2">현재 (두번째 카드)</h3>
                                    <p className={`text-indigo-100 whitespace-pre-wrap leading-relaxed ${currentTypingKey === 'present' ? 'typing-cursor' : ''}`}>{typedInterpretation.present}</p>
                                </div>
                            )}
                            {(typedInterpretation.future || currentTypingKey === 'future') && (
                                <div className="animate-fade-in">
                                    <h3 className="text-xl font-bold text-purple-300 mb-2 border-b-2 border-purple-400/30 pb-2">미래 (세번째 카드)</h3>
                                    <p className={`text-indigo-100 whitespace-pre-wrap leading-relaxed ${currentTypingKey === 'future' ? 'typing-cursor' : ''}`}>{typedInterpretation.future}</p>
                                </div>
                            )}
                            {(typedInterpretation.summary || currentTypingKey === 'summary') && (
                                <div className="animate-fade-in">
                                    <h3 className="text-xl font-bold text-green-300 mb-2 border-b-2 border-green-400/30 pb-2">총운 및 조언</h3>
                                    <p className={`text-indigo-100 whitespace-pre-wrap leading-relaxed ${currentTypingKey === 'summary' ? 'typing-cursor' : ''}`}>{typedInterpretation.summary}</p>
                                </div>
                            )}
                        </div>
                    )}
                </div>

                <button onClick={handleReset} className="mt-12 px-8 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition-all duration-300 transform hover:scale-105">새로운 리딩 시작하기</button>
              </div>
            );
          }
        };

        return (
          <div className="min-h-screen bg-gradient-to-b from-gray-900 via-indigo-950 to-black text-white font-sans p-4 sm:p-8 flex flex-col items-center">
            <ParticleCanvas />
            <header className={`text-center mb-6 w-full transition-filter duration-500 ${gameState !== 'question' ? 'blur-sm' : ''}`}>
              <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-300 tracking-wider">Taro</h1>
            </header>
            <main className="w-full max-w-screen-xl flex flex-col items-center justify-center flex-grow">{renderContent()}</main>
            <footer className={`text-center text-gray-500 mt-auto text-sm pt-8 transition-filter duration-500 ${gameState !== 'question' ? 'blur-sm' : ''}`}>
              <p>타로 리딩은 오락용으로만 즐겨주세요.</p>
            </footer>
          </div>
        );
      };

      // --- From index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
</body>
</html>